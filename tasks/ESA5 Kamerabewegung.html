<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>ESA 5 - Kamerabewegung</title>

  <!-- Dokumentation

  Author: Nina Gierke
  -->

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #262630;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      min-height: 100vh;

      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
    }

    #task {
      max-width: 600px;
      margin-bottom: 40px;
    }

    #panelCanvas {
      display: flex;
      flex-direction: row;
      /* Nebeneinander statt untereinander */
      align-items: flex-start;
      justify-content: center;
      gap: 30px;
      /* Abstand zwischen den Canvases */
      width: 100%;
      flex-wrap: wrap;
      /* Falls Bildschirm zu klein ist, umbrechen */
    }

    canvas {
      width: 550px;
      height: 550px;
      background: #ffffff;
      display: block;
    }
  </style>
</head>

<body>
  <h1>ESA 5 - Kamerabewegung</h1>

  <div id="task">
    <h3>Aufgabenstellung</h3>
    <p>
      1 - Erzeugen Sie zwei neue parametrisierte Flächen (die nicht im Modul vorkommen)
      zunächst mit Linien, siehe Material (dort gibt es viele Formeln, die Sie verwenden können).
      <br><br>
      2 - Füllen Sie dann die Flächen und kolorieren Sie sie passend zur jeweiligen Flächenform,
      z. B. mit Farbverläufen. Die Linien sollen noch sichtbar sein, oder es besteht die Möglichkeit,
      zwischen Linien und Füllung umzuschalten.
      <br><br>
      3 - Kreieren Sie auch eine eigene Parametrisierung für eine Fläche und kolorieren Sie diese.
      Dazu sollen Sie sich eine neue Formel ausdenken [...]
    </p>

    <p>Als Inspiration wurde die Seite http://www.3d-meier.de/tut3/Seite0.html verwendet.</p>
    <p>Author: Nina Gierke</p>
  </div>

  <div id="panelCanvas">
    <canvas id="canvas" width="1200" height="1200"></canvas>

  </div>



  <script>
    function render(canvas, mode) {

      let gl = canvas.getContext("experimental-webgl");
      gl.clearColor(1, 1, 1, 1);
      gl.enable(gl.DEPTH_TEST);

      /* Shader */
      const vsSource = `
      attribute vec3 pos;
      attribute vec4 col;
      varying vec4 vColor;
      void main(){
        vColor = col;
        gl_Position = vec4(pos, 1.0);
      }
    `;
      const fsSource = `
      precision mediump float;
      varying vec4 vColor;
      void main() {
        gl_FragColor = vColor;
      }
    `;

      function compile(type, src) {
        let s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
      }
      let prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSource));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSource));
      gl.linkProgram(prog);
      gl.useProgram(prog);

      let vertices, colors, lineIndices, fillIndices;

      if (mode === "pseudosphere") createPseudosphere();
      if (mode === "sanduhr") createSanduhr();
      if (mode === "qualle") createQualle();

      let vboPos = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      let aPos = gl.getAttribLocation(prog, "pos");
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPos);

      let vboCol = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      let aCol = gl.getAttribLocation(prog, "col");
      gl.vertexAttribPointer(aCol, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aCol);

      let iboFill = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboFill);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fillIndices, gl.STATIC_DRAW);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, fillIndices.length, gl.UNSIGNED_SHORT, 0);

      let iboLine = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIndices, gl.STATIC_DRAW);

      gl.disableVertexAttribArray(aCol);
      gl.vertexAttrib4f(aCol, 0, 0, 0, 1);

      gl.lineWidth(1.0);
      gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);

      gl.enableVertexAttribArray(aCol);




      function setup(n, m) {
        vertices = new Float32Array(3 * (n + 1) * (m + 1));
        colors = new Float32Array(4 * (n + 1) * (m + 1));
        lineIndices = [];
        fillIndices = [];

        return { n, m };
      }

      function connectGrid(n, m) {

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < m; j++) {
            let a = i * (m + 1) + j;
            let b = a + 1;
            let c = (i + 1) * (m + 1) + j;
            let d = c + 1;

            // Linien
            lineIndices.push(a, b, a, c);

            // Dreiecke
            fillIndices.push(a, b, c, b, d, c);
          }
        }
        lineIndices = new Uint16Array(lineIndices);
        fillIndices = new Uint16Array(fillIndices);
      }

      function colorByHeight(v, j, m) {
        let h = j / m;
        colors[4 * v] = 0.2 * (1 - h);
        colors[4 * v + 1] = 0.5 + 0.5 * h;
        colors[4 * v + 2] = 1;
        colors[4 * v + 3] = 1;
      }

function createPseudosphere() {
  let treeCount = 3;
  let n = 32, m = 40;
  let trunkHeight = 0.3;
  let coneHeight = 0.8;
  let totalHeight = trunkHeight + coneHeight;

  let trunkRadius = 0.08;
  let coneBaseRadius = 0.35;

  let xOffsets = [-0.6, 0, 0.6]; // Baumpositionen

  // Gesamte Vertexmenge (alle Bäume)
  setup(n * treeCount, m);

  let vertexIndex = 0;

  function addTree(xOffset) {
    let baseIndex = vertexIndex;

    for (let i = 0; i <= n; i++) {
      let u = (i / n) * Math.PI * 2;
      for (let j = 0; j <= m; j++) {
        let v = j / m;

        let x, y, z;

        if (v < trunkHeight / totalHeight) {
          let h = v / (trunkHeight / totalHeight);
          let r = trunkRadius;

          x = r * Math.cos(u);
          y = h * trunkHeight - 0.5;
          z = r * Math.sin(u);

          colors[4 * vertexIndex + 0] = 0.4;
          colors[4 * vertexIndex + 1] = 0.25;
          colors[4 * vertexIndex + 2] = 0.1;
          colors[4 * vertexIndex + 3] = 1;

        } else {
          let h = (v - trunkHeight / totalHeight) / (coneHeight / totalHeight);
          let r = coneBaseRadius * (1 - h);

          x = r * Math.cos(u);
          y = trunkHeight + h * coneHeight - 0.5;
          z = r * Math.sin(u);

          colors[4 * vertexIndex + 0] = 0.1 + 0.4 * Math.random();
          colors[4 * vertexIndex + 1] = 0.6 + 0.3 * Math.random();
          colors[4 * vertexIndex + 2] = 0.1;
          colors[4 * vertexIndex + 3] = 1;
        }

        vertices[3 * vertexIndex + 0] = x + xOffset;
        vertices[3 * vertexIndex + 1] = y;
        vertices[3 * vertexIndex + 2] = z;

        vertexIndex++;
      }
    }

    // lokales connect grid für diesen Baum
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < m; j++) {
        let a = baseIndex + i * (m + 1) + j;
        let b = a + 1;
        let c = baseIndex + (i + 1) * (m + 1) + j;
        let d = c + 1;

        lineIndices.push(a, b, a, c);
        fillIndices.push(a, b, c, b, d, c);
      }
    }
  }

  // Drei Bäume hinzufügen
  addTree(xOffsets[1]);
  addTree(xOffsets[0.5]);

  lineIndices = new Uint16Array(lineIndices);
  fillIndices = new Uint16Array(fillIndices);
}


    }

    //Render
    render(document.getElementById("canvas"), "pseudosphere");

  </script>



</body>

</html>