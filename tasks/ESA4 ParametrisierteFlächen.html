<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>ESA 4 - Parametrisierte Fl√§chen</title>

  <!-- Dokumentation

  Author: Nina Gierke
  -->

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #262630;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      min-height: 100vh;

      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
    }

    #task {
      max-width: 600px;
      margin-bottom: 40px;
    }

    #panelCanvas {
      display: flex;
      flex-direction: row;
      /* Nebeneinander statt untereinander */
      align-items: flex-start;
      justify-content: center;
      gap: 30px;
      /* Abstand zwischen den Canvases */
      width: 100%;
      flex-wrap: wrap;
      /* Falls Bildschirm zu klein ist, umbrechen */
    }

    canvas {
      width: 550px;
      height: 550px;
      background: #ffffff;
      display: block;
    }
  </style>
</head>

<body>
  <h1>ESA 4 - Parametrisierte Fl√§chen</h1>

  <div id="task">
    <h3>Aufgabenstellung</h3>
    <p>
      1 - Erzeugen Sie zwei neue parametrisierte Fl√§chen (die nicht im Modul vorkommen)
      zun√§chst mit Linien, siehe Material (dort gibt es viele Formeln, die Sie verwenden k√∂nnen).
      <br><br>
      2 - F√ºllen Sie dann die Fl√§chen und kolorieren Sie sie passend zur jeweiligen Fl√§chenform,
      z. B. mit Farbverl√§ufen. Die Linien sollen noch sichtbar sein, oder es besteht die M√∂glichkeit,
      zwischen Linien und F√ºllung umzuschalten.
      <br><br>
      3 - Kreieren Sie auch eine eigene Parametrisierung f√ºr eine Fl√§che und kolorieren Sie diese.
      Dazu sollen Sie sich eine neue Formel ausdenken [...]
    </p>

    <p>Als Vorlage wurde das Kursmaterial verwendet und anschlie√üend angepasst.</p>
    <p>Author: Nina Gierke</p>
  </div>

  <div id="panelCanvas">
    <canvas id="canvas" width="800" height="800"></canvas>
    <canvas id="canvas2" width="800" height="800"></canvas>
    <canvas id="canvas3" width="800" height="800"></canvas>
  </div>



  <script>
    function render(canvas, mode) {

      let gl = canvas.getContext("experimental-webgl");
      gl.clearColor(1, 1, 1, 1);
      gl.enable(gl.DEPTH_TEST);

      /* Shader */
      const vsSource = `
      attribute vec3 pos;
      attribute vec4 col;
      varying vec4 vColor;
      void main(){
        vColor = col;
        gl_Position = vec4(pos, 1.0);
      }
    `;
      const fsSource = `
      precision mediump float;
      varying vec4 vColor;
      void main() {
        gl_FragColor = vColor;
      }
    `;

      function compile(type, src) {
        let s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
      }
      let prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSource));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSource));
      gl.linkProgram(prog);
      gl.useProgram(prog);

      let vertices, colors, lineIndices, fillIndices;

      if (mode === "pseudosphere") createPseudosphere();
      if (mode === "sanduhr") createSanduhr();
      if (mode === "qualle") createQualle();

      let vboPos = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      let aPos = gl.getAttribLocation(prog, "pos");
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPos);

      let vboCol = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      let aCol = gl.getAttribLocation(prog, "col");
      gl.vertexAttribPointer(aCol, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aCol);

      let iboFill = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboFill);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fillIndices, gl.STATIC_DRAW);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.drawElements(gl.TRIANGLES, fillIndices.length, gl.UNSIGNED_SHORT, 0);

      let iboLine = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIndices, gl.STATIC_DRAW);

      gl.disableVertexAttribArray(aCol);
      gl.vertexAttrib4f(aCol, 0, 0, 0, 1);

      gl.lineWidth(1.0);
      gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);

      gl.enableVertexAttribArray(aCol);




      function setup(n, m) {
        vertices = new Float32Array(3 * (n + 1) * (m + 1));
        colors = new Float32Array(4 * (n + 1) * (m + 1));
        lineIndices = [];
        fillIndices = [];

        return { n, m };
      }

      function connectGrid(n, m) {

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < m; j++) {
            let a = i * (m + 1) + j;
            let b = a + 1;
            let c = (i + 1) * (m + 1) + j;
            let d = c + 1;

            // Linien
            lineIndices.push(a, b, a, c);

            // Dreiecke
            fillIndices.push(a, b, c, b, d, c);
          }
        }
        lineIndices = new Uint16Array(lineIndices);
        fillIndices = new Uint16Array(fillIndices);
      }

      function colorByHeight(v, j, m) {
        let h = j / m;
        colors[4 * v] = 0.2 * (1 - h);
        colors[4 * v + 1] = 0.5 + 0.5 * h;
        colors[4 * v + 2] = 1;
        colors[4 * v + 3] = 1;
      }

      //Sanduhr
      function createSanduhr() {
        let n = 64, m = 40;
        setup(n, m);
        let R0 = 0.8, H = 1.6, k = 1.8;
        let dt = 2 * Math.PI / n, dy = H / m;

        for (let i = 0, t = 0; i <= n; i++, t += dt)
          for (let j = 0; j <= m; j++) {
            let v = i * (m + 1) + j;
            let y = -H / 2 + j * dy;
            let ny = (2 * y) / H;
            let R = R0 * (1 - k * (1 - ny * ny));
            vertices[3 * v] = R * Math.cos(t);
            vertices[3 * v + 1] = y;
            vertices[3 * v + 2] = R * Math.sin(t);
            colorByHeight(v, j, m);
          }
        connectGrid(n, m);
      }

      // Pseudosphere
      function createPseudosphere() {
        let n = 32, m = 20;
        setup(n, m);

        let uMin = -Math.PI, uMax = Math.PI;
        let vMin = 0.1, vMax = 3.05;
        let du = (uMax - uMin) / n;
        let dv = (vMax - vMin) / m;

        let scale = 0.3; // üîπ kleinerer Wert = kleinere Figur

        for (let i = 0; i <= n; i++) {
          let u = uMin + i * du;
          for (let j = 0; j <= m; j++) {
            let v = vMin + j * dv;
            let idx = i * (m + 1) + j;

            // Parametergleichungen
            let x = Math.cos(u) * Math.sin(v);
            let y = Math.sin(u) * Math.sin(v);
            let z = Math.cos(v) + Math.log(Math.tan(v / 2));

            // üîπ Skalierung anwenden
            x *= scale;
            y *= scale;
            z *= scale;

            vertices[3 * idx] = x;
            vertices[3 * idx + 1] = z;
            vertices[3 * idx + 2] = y;

            colorByHeight(idx, j, m);
          }
        }
        connectGrid(n, m);
      }

      // Qualle
      function createQualle() {
        let n = 64, m = 60;
        setup(n, m);
        let R = 0.6, H = 1.8, a = 0.25, k = 6;
        let dt = 2 * Math.PI / n, dy = H / m;

        for (let i = 0, t = 0; i <= n; i++, t += dt)
          for (let j = 0; j <= m; j++) {
            let v = i * (m + 1) + j;
            let y = -H / 2 + j * dy;
            let r = R + a * Math.sin(k * y * 2.0);
            vertices[3 * v] = r * Math.cos(t);
            vertices[3 * v + 1] = y;
            vertices[3 * v + 2] = r * Math.sin(t);

            // Farbverlauf
            let h = j / m;
            let pink = [1.0, 0.4, 0.7];
            let lila = [0.6, 0.2, 0.8];
            let yellow = [1.0, 1.0, 0.2];

            if (i % 2 === 0) {
              // jede zweite vertikale Reihe gelb
              colors[4 * v] = yellow[0];
              colors[4 * v + 1] = yellow[1];
              colors[4 * v + 2] = yellow[2];
              colors[4 * v + 3] = 1.0;
            } else {
              // sonst Farbverlauf
              colors[4 * v] = pink[0] * (1 - h) + lila[0] * h;
              colors[4 * v + 1] = pink[1] * (1 - h) + lila[1] * h;
              colors[4 * v + 2] = pink[2] * (1 - h) + lila[2] * h;
              colors[4 * v + 3] = 1.0;
            }
          }
        connectGrid(n, m);
      }
    }

    //Render
    render(document.getElementById("canvas"), "pseudosphere");
    render(document.getElementById("canvas2"), "sanduhr");
    render(document.getElementById("canvas3"), "qualle");

  </script>



</body>

</html>