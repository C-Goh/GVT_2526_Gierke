<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>ESA 4 - Parametrisierte Flächen</title>

  <!-- Dokumentation

  Author: Nina Gierke
  -->

<style>
  body {
    font-family: Arial, sans-serif;
    background: #262630;
    color: #ffffff;
    margin: 0;
    padding: 20px;
    min-height: 100vh;

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
  }

  h1 {
    text-align: center;
    margin-bottom: 30px;
  }

  #task {
    max-width: 600px;
    margin-bottom: 40px;
  }

  #panelCanvas {
    display: flex;
    flex-direction: row; /* Nebeneinander statt untereinander */
    align-items: flex-start;
    justify-content: center;
    gap: 30px; /* Abstand zwischen den Canvases */
    width: 100%;
    flex-wrap: wrap; /* Falls Bildschirm zu klein ist, umbrechen */
  }

  canvas {
    width: 550px;
    height: 550px;
    background: #ffffff;
    display: block;
  }
</style>
</head>

<body>
  <h1>ESA 4 - Parametrisierte Flächen</h1>

  <div id="task">
    <h3>Aufgabenstellung</h3>
    <p>
      1 - Erzeugen Sie zwei neue parametrisierte Flächen (die nicht im Modul vorkommen)
      zunächst mit Linien, siehe Material (dort gibt es viele Formeln, die Sie verwenden können).
      <br><br>
      2 - Füllen Sie dann die Flächen und kolorieren Sie sie passend zur jeweiligen Flächenform,
      z. B. mit Farbverläufen. Die Linien sollen noch sichtbar sein, oder es besteht die Möglichkeit,
      zwischen Linien und Füllung umzuschalten.
      <br><br>
      3 - Kreieren Sie auch eine eigene Parametrisierung für eine Fläche und kolorieren Sie diese.
      Dazu sollen Sie sich eine neue Formel ausdenken [...]
    </p>

    <p>Als Vorlage wurde das Kursmaterial verwendet und anschließend angepasst.</p>
    <p>Author: Nina Gierke</p>
  </div>

  <div id="panelCanvas">
    <canvas id="canvas" width="800" height="800"></canvas>
    <canvas id="canvas2" width="800" height="800"></canvas>
    <canvas id="canvas3" width="800" height="800"></canvas>
  </div>



<script>
function render(canvas, mode) {

  let gl = canvas.getContext("experimental-webgl");
  gl.clearColor(1,1,1,1);
  gl.enable(gl.DEPTH_TEST);

  /* Shader */
  const vsSource = `
    attribute vec3 pos;
    attribute vec4 col;
    varying vec4 vColor;
    void main(){
      vColor = col;
      gl_Position = vec4(pos, 1.0);
    }
  `;
  const fsSource = `
    precision mediump float;
    varying vec4 vColor;
    void main() {
      gl_FragColor = vColor;
    }
  `;

  function compile(type, src){
    let s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
  }
  let prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSource));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSource));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  let vertices, colors, lineIndices, fillIndices;

  if(mode==="zylinder") createZylinder();
  if(mode==="sanduhr")  createSanduhr();
  if(mode==="qualle")   createQualle();

  /* Position buffer */
  let vboPos = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  let aPos = gl.getAttribLocation(prog,"pos");
  gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(aPos);

  /* Color buffer */
  let vboCol = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCol);
  gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
  let aCol = gl.getAttribLocation(prog,"col");
  gl.vertexAttribPointer(aCol,4,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(aCol);

  /* Fill (triangles) */
  let iboFill = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboFill);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fillIndices, gl.STATIC_DRAW);

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawElements(gl.TRIANGLES, fillIndices.length, gl.UNSIGNED_SHORT, 0);

  /* Line overlay = Schwarz */
  let iboLine = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLine);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, lineIndices, gl.STATIC_DRAW);

  /* Farbe für Linien überschreiben */
  gl.disableVertexAttribArray(aCol);       // keine Farb-Attribute mehr lesen
  gl.vertexAttrib4f(aCol, 0, 0, 0, 1);     // Schwarz setzen (R,G,B,A)

  /* Linien zeichnen */
  gl.lineWidth(1.0);
  gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);

  /* Farb-Attribute wieder aktivieren für nächste Figur */
  gl.enableVertexAttribArray(aCol);


  /* -------- SHAPE FUNCTIONS -------- */

  function setup(n,m){
    vertices = new Float32Array(3*(n+1)*(m+1));
    colors   = new Float32Array(4*(n+1)*(m+1));
    lineIndices = [];
    fillIndices = [];

    return {n,m};
  }

  function connectGrid(n,m){
    // Linien und Dreiecke erzeugen
    for(let i=0;i<n;i++){
      for(let j=0;j<m;j++){
        let a=i*(m+1)+j;
        let b=a+1;
        let c=(i+1)*(m+1)+j;
        let d=c+1;

        // Linien
        lineIndices.push(a,b, a,c);

        // Dreiecke (Flächenfüllung)
        fillIndices.push(a,b,c,  b,d,c);
      }
    }
    lineIndices = new Uint16Array(lineIndices);
    fillIndices = new Uint16Array(fillIndices);
  }

  function colorByHeight(v,j,m){
    let h=j/m;
    colors[4*v]   = 0.2*(1-h);
    colors[4*v+1] = 0.5+0.5*h;
    colors[4*v+2] = 1;
    colors[4*v+3] = 1;
  }

  /* --- Sanduhr --- */
  function createSanduhr(){
    let n=64, m=40;
    setup(n,m);
    let R0=0.8, H=1.6, k=1.8;
    let dt=2*Math.PI/n, dy=H/m;

    for(let i=0,t=0;i<=n;i++,t+=dt)
    for(let j=0;j<=m;j++){
      let v=i*(m+1)+j;
      let y=-H/2+j*dy;
      let ny=(2*y)/H;
      let R=R0*(1-k*(1-ny*ny));
      vertices[3*v]=R*Math.cos(t);
      vertices[3*v+1]=y;
      vertices[3*v+2]=R*Math.sin(t);
      colorByHeight(v,j,m);
    }
    connectGrid(n,m);
  }

  /* --- Zylinder --- */
  function createZylinder(){
    let n=64, m=40;
    setup(n,m);
    let R=0.8, H=1.6;
    let dt=2*Math.PI/n, dy=H/m;

    for(let i=0,t=0;i<=n;i++,t+=dt)
    for(let j=0;j<=m;j++){
      let v=i*(m+1)+j;
      let y=-H/2+j*dy;
      vertices[3*v]=R*Math.cos(t);
      vertices[3*v+1]=y;
      vertices[3*v+2]=R*Math.sin(t);
      colorByHeight(v,j,m);
    }
    connectGrid(n,m);
  }

  /* --- eigene Fläche: Qualle/Vase --- */
  function createQualle(){
    let n=64, m=60;
    setup(n,m);
    let R=0.6, H=1.8, a=0.25, k=6;
    let dt=2*Math.PI/n, dy=H/m;

    for(let i=0,t=0;i<=n;i++,t+=dt)
    for(let j=0;j<=m;j++){
      let v=i*(m+1)+j;
      let y=-H/2+j*dy;
      let r=R + a*Math.sin(k*y*2.0);
      vertices[3*v]=r*Math.cos(t);
      vertices[3*v+1]=y;
      vertices[3*v+2]=r*Math.sin(t);
      colorByHeight(v,j,m);
    }
    connectGrid(n,m);
  }
}

/* render canvases */
render(document.getElementById("canvas"), "zylinder");
render(document.getElementById("canvas2"), "sanduhr");
render(document.getElementById("canvas3"), "qualle");
</script>



</body>

</html>