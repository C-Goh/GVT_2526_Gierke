<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>ESA 4 - Parametrisierte Flächen</title>

  <!-- Dokumentation

  Author: Nina Gierke
  -->

  <style>
    body {

      font-family: Arial, sans-serif;
      background: #262630;
      color: #ffffff;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    canvas {
      display: block;
      width: 550px;
      ;
      height: 550px;
      ;
      background: #ffffff;
    }

    h1 {
      text-align: center;
      color: #ffffff;
      margin-bottom: 60px;
    }

    #content {
      display: flex;
      gap: 80px;
    }

    #task {
      width: 40%;
      margin-left: 100px;
    }
  </style>
</head>

<body>
  <h1>ESA 4 - Parametrisierte Flächen</h1>
  <div id="content">

    <div id="task">
      <h3>Aufgabenstellung</h3>
      <p>
        1 - Erzeugen Sie zwei neue parametrisierte Flächen (die nicht im Modul vorkommen)
        zunächst mit Linien, siehe Material (dort gibt es viele Formeln, die Sie verwenden können).

        2 - Füllen Sie dann die Flächen und kolorieren Sie sie passend zur jeweiligen Flächenform,
        z. B. mit Farbverläufen. Die Linien sollen noch sichtbar sein, oder es besteht die Möglichkeit,
        zwischen Linien und Füllung umzuschalten.

        3 - Kreieren Sie auch eine eigene Parametrisierung für eine Fläche und kolorieren Sie diese.
        Dazu sollen Sie sich eine neue Formel ausdenken, diese können Sie natürlich auf der Basis
        der vorhandenen Formeln aufbauen (aus dem Modul oder aus dem Material).
        Versuchen Sie Terme zu mischen und schauen Sie, ob das passiert, was Sie erwarten.
        Alternativ suchen Sie sich eine Form und versuchen Sie diese zu erzeugen,
        vielleicht „eine Qualle“ oder Ihre Lampe (dieses Vorgehen ist meist schwieriger).
      </p>
      <p>Als Vorlage wurde das Kursmaterial verwendet und anschließend angepasst.</p>

      <p> Author: Nina Gierke</p>
    </div>

    <div>
      <canvas id="canvas" width="800" height="800"></canvas>
    </div>

  </div>


  <script>
    // Get the WebGL context.
    var canvas = document.getElementById('canvas');
    var gl = canvas.getContext('experimental-webgl');

    // Pipeline setup.
    gl.clearColor(.95, .95, .95, 1);
    // Backface culling.
    gl.frontFace(gl.CCW);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    // Compile vertex shader. 
    var vsSource = '' +
      'attribute vec3 pos;' +
      'attribute vec4 col;' +
      'varying vec4 color;' +
      'void main(){' + 'color = col;' +
      'gl_Position = vec4(pos, 1);' +
      '}';
    var vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);

    // Compile fragment shader.
    fsSouce = 'precision mediump float;' +
      'varying vec4 color;' +
      'void main() {' +
      'gl_FragColor = color;' +
      '}';
    var fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSouce);
    gl.compileShader(fs);

    // Link shader together into a program.
    var prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.bindAttribLocation(prog, 0, "pos");
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // Vertex data.
    // Positions, index data.
    var vertices, indices;
    // Fill the data arrays.
    createVertexData();

    // Setup position vertex buffer object.
    var vboPos = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
    gl.bufferData(gl.ARRAY_BUFFER,
      vertices, gl.STATIC_DRAW);
    // Bind vertex buffer to attribute variable.
    var posAttrib = gl.getAttribLocation(prog, 'pos');
    gl.vertexAttribPointer(posAttrib, 3,
      gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(posAttrib);

    // Setup constant color.
    var colAttrib = gl.getAttribLocation(prog, 'col');
    gl.vertexAttrib4f(colAttrib, 0, 0, 1, 1);

    // Setup index buffer object.
    var ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
      indices, gl.STATIC_DRAW);
    ibo.numberOfElements = indices.length;

    // Clear framebuffer and render primitives.
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawElements(gl.LINE_STRIP,
      ibo.numberOfElements, gl.UNSIGNED_SHORT, 0);

    function createVertexData() {
    var n = 64; // Winkelunterteilung
    var m = 30; // Höhenunterteilung
    var Rbase = 0.8; // Maximaler Radius (oben/unten)
    var H = 1.6;     // Höhe
    var k = 1.8;     // Einschnürung (0 = Zylinder, 1 = stark eingeschnürt)

    vertices = new Float32Array(3 * (n + 1) * (m + 1));
    indices  = new Uint16Array(2 * 2 * n * m);

    var dt = 2 * Math.PI / n;
    var dy = H / m;
    var iIndex = 0;

    for (var i = 0, t = 0; i <= n; i++, t += dt) {
        for (var j = 0; j <= m; j++) {
            var iVertex = i * (m + 1) + j;
            var y = -H / 2 + j * dy;

            // normierte Höhe [-1, +1]
            var ny = (2 * y) / H;

            // Sanduhr: in der Mitte schmal, oben/unten breit
            var R = Rbase * (1 - k * (1 - ny * ny));

            var x = R * Math.cos(t);
            var z = R * Math.sin(t);

            vertices[iVertex * 3]     = x;
            vertices[iVertex * 3 + 1] = y;
            vertices[iVertex * 3 + 2] = z;

            // Linien
            if (j > 0) {
                indices[iIndex++] = iVertex - 1;
                indices[iIndex++] = iVertex;
            }
            if (i > 0) {
                indices[iIndex++] = iVertex - (m + 1);
                indices[iIndex++] = iVertex;
            }
        }
    }
}


  </script>


</body>

</html>